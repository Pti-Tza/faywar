extends BaseController
class_name AIController

### Class-level documentation ###
'''
AIController manages AI-controlled units during their turn.
It generates and executes plans based on the assigned AI strategy.
'''

### Exported Properties ###
@export var ai_strategy: AIStrategy
    # AI strategy resource
@export var decision_delay: float = 0.5
    # Delay before executing the next action


    # Reference to the unit currently controlled
var _current_plan: Dictionary = {}
    # Current plan generated by the AI strategy
var _decision_timer: float = 0.0
    # Timer for decision-making

### Public API ###
func begin_turn(unit: Node) -> void:
    '''
    @brief Begins the turn for the AI-controlled unit
    @param unit: Node - The unit to control
    '''
    super.begin_turn(unit)
    assert(ai_strategy != null, "AI strategy cannot be null")
    assert(MovementSystem != null, "MovementSystem reference is missing")
    assert(AttackSystem != null, "AttackSystem reference is missing")
    
    _current_unit = unit
    ai_strategy.initialize(unit)
    _generate_plan()

func process_turn(delta: float) -> void:
    '''
    @brief Processes the AI's turn logic
    @param delta: float - Time elapsed since the last frame
    '''
    _decision_timer += delta
    if _decision_timer >= decision_delay:
        _execute_next_action()
        _decision_timer = 0.0

func end_turn() -> void:
    '''
    @brief Ends the turn and resets internal state
    '''
    _current_unit = null
    _current_plan = {}
    super.end_turn()

### Private Implementation ###
func _generate_plan():
    '''
    @brief Generates a plan based on the AI strategy
    '''
    _current_plan = {
        "movement": ai_strategy.calculate_movement(),
        "combat": ai_strategy.calculate_combat(),
        "priority": ai_strategy.get_priority()
    }

func _execute_next_action():
    '''
    @brief Executes the next action in the plan
    '''
    if _current_plan.movement.valid:
        _execute_movement()
    elif _current_plan.combat.valid:
        _execute_combat()
    else:
        end_turn()

func _execute_movement():
    '''
    @brief Executes the movement action
    '''
    hex_grid.find_unit_path(
        _current_unit,
        _current_plan.movement.target,
        ai_strategy.movement_speed
    )
    action_selected.emit("move")

func _execute_combat():
    '''
    @brief Executes the combat action
    '''
    attack_system.resolve_attack(
        _current_unit,
        _current_plan.combat.target,
        _current_plan.combat.weapon
    )
    action_selected.emit("attack")